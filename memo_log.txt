qbuffer 은 송신용
rx_buf 는 수신용으로 선언 

수신 = 인터럽트
송신 = 폴링

* HAL_UART_Receive_IT(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE)
수신 인터럽트 함수

** HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
완료되었을 때 콜백함수

HAL_UART_IRQHandler는 인터럽트 핸들러 함수이다. 
<HAL_UART_IRQHandler의 역할>
1. HAL_UART_ErrorCallback(huart) 호출
2. 수신 됐을 경우에 UART_Receive_IT를 호출하고
3. HAL_UART_RxCpltCallback(huart)를 호출 

__weak 타입은 다른 파일에서 같은 함수를 만들면 새롭게 만들어진 non-weak 타입이 호출된다.

수신버퍼 사이즈를 지정해주는 작업이 uartOpen에 추가되어야함
	-> HAL_UART_Receive_IT 함수 예시

  if(HAL_UART_Receive_IT(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE) != HAL_OK)
  {
    /* Transfer error in reception process */
    Error_Handler();
  }

 예시처럼 호출하면 aRxBuffer에 수신 데이터가 저장될 것이다.

 <디버깅>
   숫자 1입력시,
   HAL_UART_RxCpltCallback 호출 >> qbufferWrite >> HAL_UART_Receive_IT

   rx_data 에 아스키 49 들어온거 확인 

   !! : HAL_UART_RxCpltCallback 에서 HAL_UART_Receive_IT 를 다시 호출하여 한바이트를 받을 수 있도록 해주어야한다. 

      UART 인터럽트 함수를 browse 하다보면 UART_Recieve_IT 함수에서 컴플리트를 하기전에 인터럽트를 비활성화 시킨다.


      바람선생님께서는 빠르게 송신할때 인터럽트도 많이 걸리게 되어 overrun을 겪으신 적이 있음.
      -> DMA가 차선책


--------------------------------------------------------------------------------------------
< UART #3 DMA>

4. DMA stream x number of data register (DMA_SxNDTR) (x = 0..7)
    이 레지스터를 활용할 것 
    enable 를 하고 receive dma 함수 호출 하면, 현 레지스터가 사이즈만큼 세팅,
    수신쪽에 데이터 들어오면 하나씩 감소됨.

    qbuffer 에서 별도로 write 할 필요가 없어짐.

    그렇다면 인덱스 관리는?

5. 인덱스 관리
    기존에는 write가 interrupt 함수에서 적용되었지만 지금은 그렇게 안하기 때문에
    uartAvailable 에서
      버퍼의 in인덱스가 dma의 핸들러의 instance의 레지스터 값을 참고한다. 
      qbuffer[_DEF_UART2].in = hdma_usart1_rx.Instance->NDTR;

--------------------------------------------------------------------------------------------
< UART #4 usb to Serial>
- usb rx -> tx to uart (반대도 마찬가지)

1. HAL_uart_deinit 하는 이유  
    속도를 바꿔 오픈하게 되면 다시 오픈해야하는 상황이 가끔 있음.
    현재 오픈된 상태에서 다시 재오픈 하기 위해서는 deinit함수 호출이 필요 

2. usb 같은 경우 보드레이트 바뀐다해서 통신이 안되진 않음 
  그러나 물리적 유아트는 바꿔줘야함
  usb가 바뀌면 uart도 바뀌어야함.
  